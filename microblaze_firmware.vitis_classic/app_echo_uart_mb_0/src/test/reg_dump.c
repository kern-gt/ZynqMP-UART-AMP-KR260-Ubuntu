/*
    reg_dump.c
    author: sh-goto
    description:
        下記のペリフェラルレジスタのダンプをします.
        Dump the following peripheral registers.

            * PLx_REF_CTRL Register (x=0~3)


        * About PLx_REF_CTRL Register
            UG1087(https://docs.amd.com/r/en-US/ug1087-zynq-ultrascale-registers/PL0_REF_CTRL-CRL_APB-Register)

            これはFCLK(PL ファブリッククロック)の周波数を設定するレジスタです.
            FCLK0~3に対応しています.Kria k26 SOM(KR260ボード)は水晶発振器が
            33.333...MHzで、IOPLLが30倍にFSBLで設定されています.
            この場合、FCLK=100MHzに設定したいとすると、PLx_REF_CTRL Registerの
            分周器の値は、下記の候補になります.
                * Divider=9 : FCLK=111.111MHz
                * Divider=10 : FCLK=99.999MHz
                * Divider=11 : FCLK=90.909MHz
            分周器の分解能は約10MHz(10%)になります. UARTLiteをFCLKで駆動する
            場合、分周器の値が1ずれると、UARTLiteのボーレートのずれが10%となり、
            許容できなくなります.
            This register sets the frequency of FCLK (PL fabric clock), 
            corresponding to FCLK0~3.The Kria k26 SOM (KR260 board) has
            a crystal oscillator at 33.333...MHz and IOPLL set to 30x
            FSBL (as of July 2024). In this case, if we want to set
            FCLK = 100 MHz, the following candidates for the divider value
            in the PLx_REF_CTRL Register are
                * Divider=9 : FCLK=111.111MHz
                * Divider=10 : FCLK=99.999MHz
                * Divider=11 : FCLK=90.909MHz
            The resolution of the frequency divider is approximately
            10 MHz (10%); when UARTLite is driven by FCLK, 
            a 1 shift in the frequency divider value results in a
            10% shift in the UARTLite baud rate, which is unacceptable.


            ここで問題なのは、PLx_REF_CTRL Registerの分周器の値が
            PL Device treeのソースコードの値によって、ずれる可能性がある
            ことです.例を出します.以下を見てください.
            The problem here is that the divider value in
            the PLx_REF_CTRL Register can shift depending on the value
            in the PL Device tree source code.
            Here is an example. See below.

            &fpga_full {
	            firmware-name = "design_1_wrapper.bit.bin";
	            pid = <0x0>;
	            resets = <&zynqmp_reset 116>;
	            uid = <0x0>;
	            clocking0: clocking0 {
                    #clock-cells = <0>;
                    assigned-clock-rates = <99999001>;
                    assigned-clocks = <&zynqmp_clk 71>;
                    clock-output-names = "fabric_clk";
                    clocks = <&zynqmp_clk 71>;
                    compatible = "xlnx,fclk";
                };
            };

            "assigned-clock-rates = <99999001>;"はFCLK0=99.999001MHz
            という意味です.この周波数の値はVivadoとXSCTのcreatedtsコマンド
            で生成されたものです.この値でDevice tree Overlayを行うと、
            CCF(Common Clock Framework)がPLx_REF_CTRL Registerを
            設定します.CCFはこの周波数設定値を超えないように分周器を
            設定するため、Divider=10ではFCLK=99.999999MHzとなり
            超えてしまいます.そのため、Divider=11が設定され、
            FCLK=90.909MHzとなり、UARTLiteのボーレートがずれてしまいます.
            “assigned-clock-rates = <999999001>;” means 
            FCLK0 = 99.99999001 MHz. This frequency value is generated by
            Vivado and XSCT's createdts command. If you do
            a Device tree Overlay with this value, the CCF
            (Common Clock Framework) will set the PLx_REF_CTRL Register.
            Since the CCF sets the frequency divider so that it does not
            exceed this frequency setting value, Divider=10 will result in
            FCLK=99.99999999MHz, which exceeds the set value. 
            Therefore, Divider=11 is set and FCLK=90.909MHz, 
            resulting in a UARTLite baud rate deviation.


            上記で記述したようなケースに遭遇した場合、デバイスツリーを
            修正する必要が有ります.
            If you encounter a case like the one described above, 
            you will need to modify the device tree.

            例(Example)：assigned-clock-rates = <100000000>;
*/

/* Xilinx includes. */
#include "xil_printf.h"
#include "xparameters.h"
#include <stdint.h>

#include "reg_dump.h"

void ReadRegisterPLxRefCtrl(void)
{
    const uint32_t reg_baseaddr = 0x00FF5E0000;
    uint32_t* reg_pl0_ref_ctrl;
    uint32_t* reg_pl1_ref_ctrl;
    uint32_t* reg_pl2_ref_ctrl;
    uint32_t* reg_pl3_ref_ctrl;
    uint32_t read_reg;
    const uint32_t reg_plx_ref_ctrl_srcsel_mask   = 0x0000000007;
    const uint8_t  reg_plx_ref_ctrl_srcsel_offset   = 0U;
    const uint32_t reg_plx_ref_ctrl_divisor0_mask = 0x0000003F00;
    const uint8_t  reg_plx_ref_ctrl_divisor0_offset = 8U;
    const uint32_t reg_plx_ref_ctrl_divisor1_mask = 0x00003F0000;
    const uint8_t  reg_plx_ref_ctrl_divisor1_offset = 16U;
    const uint32_t reg_plx_ref_ctrl_clkact_mask   = 0x0001000000;
    const uint8_t  reg_plx_ref_ctrl_clkact_offset   = 24U;

    reg_pl0_ref_ctrl = (reg_baseaddr + 0x00000000C0);
    reg_pl1_ref_ctrl = (reg_baseaddr + 0x00000000C4);
    reg_pl2_ref_ctrl = (reg_baseaddr + 0x00000000C8);
    reg_pl3_ref_ctrl = (reg_baseaddr + 0x00000000CC);

    read_reg = *reg_pl0_ref_ctrl;
    xil_printf("reg_pl0_ref_ctrl = 0x%08x\n", read_reg);
    xil_printf("    reg_pl0_ref_ctrl>>srcsel = %d\n",
        ((read_reg & reg_plx_ref_ctrl_srcsel_mask)>>reg_plx_ref_ctrl_srcsel_offset));
    xil_printf("    reg_pl0_ref_ctrl>>divisor0 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor0_mask)>>reg_plx_ref_ctrl_divisor0_offset));
    xil_printf("    reg_pl0_ref_ctrl>>divisor1 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor1_mask)>>reg_plx_ref_ctrl_divisor1_offset));
    xil_printf("    reg_pl0_ref_ctrl>>clkact = %d\n",
        ((read_reg & reg_plx_ref_ctrl_clkact_mask)>>reg_plx_ref_ctrl_clkact_offset));

    read_reg = *reg_pl1_ref_ctrl;
    xil_printf("reg_pl1_ref_ctrl = 0x%08x\n", read_reg);
    xil_printf("    reg_pl1_ref_ctrl>>srcsel = %d\n",
        ((read_reg & reg_plx_ref_ctrl_srcsel_mask)>>reg_plx_ref_ctrl_srcsel_offset));
    xil_printf("    reg_pl1_ref_ctrl>>divisor0 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor0_mask)>>reg_plx_ref_ctrl_divisor0_offset));
    xil_printf("    reg_pl1_ref_ctrl>>divisor1 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor1_mask)>>reg_plx_ref_ctrl_divisor1_offset));
    xil_printf("    reg_pl1_ref_ctrl>>clkact = %d\n",
        ((read_reg & reg_plx_ref_ctrl_clkact_mask)>>reg_plx_ref_ctrl_clkact_offset));

    read_reg = *reg_pl2_ref_ctrl;
    xil_printf("reg_pl2_ref_ctrl = 0x%08x\n", read_reg);
    xil_printf("    reg_pl2_ref_ctrl>>srcsel = %d\n",
        ((read_reg & reg_plx_ref_ctrl_srcsel_mask)>>reg_plx_ref_ctrl_srcsel_offset));
    xil_printf("    reg_pl2_ref_ctrl>>divisor0 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor0_mask)>>reg_plx_ref_ctrl_divisor0_offset));
    xil_printf("    reg_pl2_ref_ctrl>>divisor1 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor1_mask)>>reg_plx_ref_ctrl_divisor1_offset));
    xil_printf("    reg_pl2_ref_ctrl>>clkact = %d\n",
        ((read_reg & reg_plx_ref_ctrl_clkact_mask)>>reg_plx_ref_ctrl_clkact_offset));

    read_reg = *reg_pl3_ref_ctrl;
    xil_printf("reg_pl3_ref_ctrl = 0x%08x\n", read_reg);
    xil_printf("    reg_pl3_ref_ctrl>>srcsel = %d\n",
        ((read_reg & reg_plx_ref_ctrl_srcsel_mask)>>reg_plx_ref_ctrl_srcsel_offset));
    xil_printf("    reg_pl3_ref_ctrl>>divisor0 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor0_mask)>>reg_plx_ref_ctrl_divisor0_offset));
    xil_printf("    reg_pl3_ref_ctrl>>divisor1 = %d\n",
        ((read_reg & reg_plx_ref_ctrl_divisor1_mask)>>reg_plx_ref_ctrl_divisor1_offset));
    xil_printf("    reg_pl3_ref_ctrl>>clkact = %d\n",
        ((read_reg & reg_plx_ref_ctrl_clkact_mask)>>reg_plx_ref_ctrl_clkact_offset));

}

